---
layout: post
title: "Problema 001"
description: ""
category: "problemas"
tags: []
---
{% include JB/setup %}


| Si listamos todos los números naturales menores que 10 que sean múltiplos de 3 o de 5, obtenemos 3, 5, 6 y 9. La suma de estos múltiplos es 23.

Halla la suma de todos los múltiplos de 3 o 5 menores que 1000.

----------


# Python


Una primera versión rudimentaria consistiría en iterar sobre la lista de números 
{% highlight python %}
def Suma1a(N):
	S=0
	for n in range(N):
	    if n%3 == 0 or n%5 ==0:
	        S=S+n

	return S

print(suma1(1000))
{% endhighlight %}


Y en una pequeña fracción de segundo, obtenemos la respuesta:
{% highlight text %}
$ time python2 euler001.py 
233168

real   0m0.034s
user   0m0.033s
sys	   0m0.000s
{% endhighlight %}


Sin embargo, el código anterior es malo malo, pero es que la tarea es tan simple, que no notamos realmente su ineficiencia. Por ello, probemos ahora con N igual a un millón (es decir, mil veces más grande).

{% highlight text %}
$ time python2 euler001.py 
233333166668

real   0m0.252s
user   0m0.220s
sys    0m0.030s

{% endhighlight %}

Sigue siendo rápido (un quinto de segundo). Pero si corremos un analizador de consumo de memoria obtendremos:

{% highlight text %}
$ python2 euler001.py 
Filename: euler001.py

Line #    Mem usage    Increment   Line Contents
================================================
     6      8.9 MiB      0.0 MiB   @profile
     7                             def Suma1a(N):
     8      8.9 MiB      0.0 MiB   	S=0
     9     40.1 MiB     31.1 MiB   	for n in range(N):
    10     40.1 MiB      0.0 MiB   	    if n%3 == 0 or n%5 ==0:
    11     40.1 MiB      0.0 MiB   	        S=S+n
    12                             
    13     32.4 MiB     -7.6 MiB   	return S

{% endhighlight %}

Observemos que algo tan simple usa un montón de memoria (arriba de 30 MB). Para darte una idea del problema, si calculáramos la suma hasta 100 millones, el programa tomaría alrededor de 15 segundos, pero usaría casi 3GB de memoria (considera que muchas computadoras tienen cuando mucho 4GB de memoria).

**¿Qué está pasando?** ¿Qué está causando este problema? 

Aunque en todo momento sólo necesitamos conocer un valor de n, entero, y decidir si es múltiplo de 3 o de 5, el programa está consumiendo memoria como troglodita.  La razón es la siguiente:


> **Cuando se usa `range()`, python crea la lista completa aunque sólo vaya a necesitar un valor a la vez, y la mantiene en memoria todo el tiempo necesario.**


Es decir, *antes* de comenzar a probar si cada valor de n, ya almacenó en memoria cien millones de enteros, y los deja ahí hasta que termina el programa.

## Generadores en Python

Un generador funciona como una lista, pero en todo momento almacena sólo un valor y cada vez que se consulta, genera el valor siguiente.  En este caso, reemplazaremos la función `range()` por `xrange()`.

{% highlight python %}
def Suma1b(N):
	S=0
	for n in xrange(N):
	    if n%3 == 0 or n%5 ==0:
	        S=S+n

	return S

print(suma1(10**6))
{% endhighlight %}

Obteniendo como resultado:

{% highlight text %}
$ python2 euler001.py 
Filename: euler001.py

Line #    Mem usage    Increment   Line Contents
================================================
    15      8.9 MiB      0.0 MiB   @profile
    16                             def Suma1b(N):
    17      8.9 MiB      0.0 MiB   	S=0
    18      9.0 MiB      0.1 MiB   	for n in xrange(N):
    19      9.0 MiB      0.0 MiB   	    if n%3 == 0 or n%5 ==0:
    20      9.0 MiB      0.0 MiB   	        S=S+n
    21                             
    22      9.0 MiB      0.0 MiB   	return S

{% endhighlight %}

la diferencia crucial está en:

{% highlight text %}
9     40.1 MiB     31.1 MiB   	for n in range(N):
18      9.0 MiB      0.1 MiB   	for n in xrange(N):
{% endhighlight %}

la versión con `range()` requirió 31 MB de memoria, mientras que `xrange()` únicamente 0.1MB.


> **MORALEJA 1: Si un rango sólo se va a usar para iterar sobre él, es mejor usar `xrange()` que `range()`.**

Ahora, no siempre es conveniente sustituir una lista por un generador. Por ejemplo, si es necesario usar más de una vez los valores de la lista, o si se debe modificar, o algún otro uso que requiera "recordar" los valores, entonces el cambio no es útil.

Lo importante a recordar es:
> Cuando se usa un generador, una vez obtenido un valor, éste "se olvida" y no es posible acceder a él de nuevo.

Para aclarar ésto, comparemos:

{% highlight python %}
L = range(10)
L[3] = 100
L
{% endhighlight %}

que resulta en `[0, 1, 2, 100, 4, 5, 6, 7, 8, 9]`.

Por otro lado:
{% highlight python %}
L = xrange(10)
L[3] = 100
{% endhighlight %}

resulta en
{% highlight text %}
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    L[3] = 100
TypeError: 'xrange' object does not support item assignment

{% endhighlight %}

ya que `L` no es en realidad una lista (es una función que genera valores de forma consecutiva) y por tanto no se pueden modificar "sus elementos".



### Python3 
En Python3 toda la discusión anterior se hace obsoleta. En Python3, la función `range()` crea un generador, no una lista, así que el problema desaparece (así como también desaparece `xrange()`). En Python3, si realmente quieres crear un rango como lista (que casi-nunca-se-hace) se usa la sintaxis `list(range())`.


Sin embargo, existen otros tipos de generadores, no sólo rangos y la moraleja sigue siendo válida incluso en Python3: si sólo se va a usar como iterador, o si no se necesita acceder a los valores de una lista más que uno a la vez y de forma secuencial, es mejor usar un generador.

Claro que, como veremos en otra entrada posterior, incluso si vamos trabajar con los elementos, si no necesitamos realmente "el orden secuencial" de los elementos de una lista, es decir, si sólo nos importa cuáles son, pero no quién va primero entre dos elementos, o si sólo nos importa determinar pertenencia más que posición, nos conviene usar un tipo de datos distinto (un diccionario o un conjunto) y no una lista.

## Eliminación de ciclos innecesarios
### Comprensiones de listas

Una de las mejores maneras de mejorar el código, es eliminar cada que sea posible los ciclos y reemplazarlos por funciones optimizadas para dichas tareas.

Retomemos el código para calcular la suma de los múltiplos de 3 y 5 hasta 100 millones. El código ya no consume tanta memoria, pero sigue careciendo de ese sabor "a Python".

Pprácticamente es una traducción literal de cómo se programaría en otros lenguajes a Python) y recuerda: * literal translations are never good * (literales traducciones son nunca buenas).

Una de las características más "pitónicas" que hay es la comprensión de lista.
Dada una lista $$L$$, una comprensión de lista es una forma rápida de describir las siguientes listas:

$$ [ f(x) : x \in L ] $$

$$ [ f(x) : x \in L \text{ tales que } P(x)] $$

donde $$P(x)$$ es una función que regresa falso o verdadero. 

La sintaxis para el primer tipo (aplicar una función a todos los elementos de una lista) sería:

{% highlight python %}
[f(x) for x in L]
{% endhighlight %}

y para la segunda:
{% highlight python %}
[f(x) for x in L  if P(x)]
{% endhighlight %}

Así obtenemos una lista con únicamente los elementos que nos interesan, y luego usaremos la función `sum()` para sumar (de manera eficiente) todos los elementos de dicha lista en una lína en vez de usar un ciclo `for` para sumarlos "de uno en uno"

{% highlight python %}
def Suma2a(N):
	return sum([n for n in range(N) if (n%3==0 or n%5==0)])
{% endhighlight %}

¡El código ahora ocupa sólo una línea!
Aquí hicimos dos cosas. Primero, reemplazamos el ciclo for por una lista "filtrada" de los elementos:

{% highlight python %}
[n for n in range(N) if (n%3==0 or n%5==0)]
{% endhighlight %}
en donde al poner `n for n` estamos señalando que la función $$f()$$ es en realidad la función identidad. Y luego, indicamos que sólo vamos a seleccionar los elementos para los cuales `(n%3==0 or n%5==0)` resulte verdadero (es decir, para los múltiplos de 3 o los múltiplos de 5).

Sin embargo, nuevamente caímos en el error de antes ( !y doblemente!): estamos usando listas y no generadores, por lo que el programa crea una lista gigantesca (al usar `range()` creamos la lista con cien millones de elementos) y luego obtenemos una lista con más 45 millones de enteros seleccionados que debemos sumar de nuevo. Por ello, este programa consume también enormes cantidades de memoria.

Claro, podemos cambiar el `range()``por `xrange()` (aunque en Python3 ya no es necesario) pero aún así nos queda la otra ineficiencia.

Ahora, así como existen comprensiones de listas, existen comprensiones de conjuntos, de tuplas, etc.  Y también existen "expresiones generadoras"

{% highlight python %}
def Suma2b(N):
	return sum(n for n in xrange(N) if (n%3==0 or n%5==0))	
{% endhighlight %}

Aquí reemplazamos `[n for n in range(N) if (n%3==0 or n%5==0)]` (que genera una lista) por `n for n in xrange(N) if (n%3==0 or n%5==0)` (que da un generador (a partir de otro generador)).

Comparemos el uso de memoria en ambos programas para N=1000000

La primera versión usó 30MB para sus listas
{% highlight text %}
Line #    Mem usage    Increment   Line Contents
================================================
    24      9.0 MiB      0.0 MiB   @profile
    25                             def Suma2a(N):
    26     43.9 MiB     34.9 MiB   	return sum([n for n in range(N) if (n%3==0 or n%5==0)])

{% endhighlight %}

pero la versión con generadores usó incluso menos memoria que la primera versión optimizada.
{% highlight text %}
Line #    Mem usage    Increment   Line Contents
================================================
    28      8.9 MiB      0.0 MiB   @profile
    29                             def Suma2b(N):
    30      8.9 MiB      0.0 MiB   	return sum(n for n in xrange(N) if (n%3==0 or n%5==0))

{% endhighlight %}

> **MORALEJA 2: De ser posible, usa comprensiones, generadores y funciones para deshacerte de ciclos for.**
> **MORALEJA 3: Usa funciones que operen sobre listas en vez de iterar sobre ellas y operar con los elementos de uno en uno.**


Ahora, hay que hacer una pequeña confesión. La ganancia en este ejemplo al trabajar con comprensiones respecto a la versión del ciclo for es mínima, debido a que es un programa muy muy simple y el intérprete puede hacer muchas optimizaciones incluso en la versión *fea*. Pero en general, en programas más complejos, el trabajar *vectorialmente* (con funciones que operen sobre listas/vectores/etc.) suele resultar más eficiente que trabajar con múltiples ciclos `for`, especialmente si están anidados.